import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';
import { Project } from '@/types';
import { githubConfig } from '../../config/github';

/**
 * Generate a markdown file for a GitHub repository project
 */
export async function generateGitHubProjectPage(project: Project) {
    // Skip if repository is in the exclude list or if it's not a GitHub repo
    const repo = project.repo;
    if (!repo || githubConfig.excludeFromPages.includes(repo)) {
        return;
    }

    // Get repository details from GitHub API
    const token = process.env.GITHUB_TOKEN;
    const headers: Record<string, string> = { Accept: 'application/vnd.github.v3+json' };
    if (token) headers.Authorization = `token ${token}`;

    // Fetch repository info including README
    const [repoRes, readmeRes] = await Promise.all([
        fetch(`https://api.github.com/repos/${repo}`, { headers }),
        fetch(`https://api.github.com/repos/${repo}/readme`, { headers }),
    ]);

    if (!repoRes.ok || !readmeRes.ok) {
        console.warn(`Failed to fetch repo data for ${repo}`);
        return;
    }

    const [repoData, readmeData] = await Promise.all([
        repoRes.json(),
        readmeRes.json(),
    ]);

    // Decode README content from base64
    const readmeContent = Buffer.from(readmeData.content, 'base64').toString('utf8');

    // Generate frontmatter
    const frontmatter = {
        title: project.title,
        date: repoData.created_at?.split('T')[0], // Use repo creation date
        tags: project.tags,
        excerpt: project.desc,
        original_path: project.link,
        stars: project.stars,
        forks: project.forks,
        gitstarRank: project.gitstarRank,
        repo: repo,
        // Mark generated files so users can opt-out of future overwrites by setting this to false
        autogenerated: true,
    };

    // Combine frontmatter with README content
    const content = matter.stringify(readmeContent, frontmatter);

    // Write to projects directory
    const projectsDir = path.join(process.cwd(), 'content/projects');
    const repoName = repo.split('/')[1];
    const fileName = `${repoName}.md`;
    const filePath = path.join(projectsDir, fileName);

    // Create directory if it doesn't exist
    if (!fs.existsSync(projectsDir)) {
        fs.mkdirSync(projectsDir, { recursive: true });
    }

    // Write file if it doesn't exist or if content has changed
    let shouldWrite = true;
    if (fs.existsSync(filePath)) {
        const existing = fs.readFileSync(filePath, 'utf8');
        // If an existing file explicitly sets autogenerated: false, do not overwrite it
        try {
            const parsed = matter(existing);
            if (parsed?.data && parsed.data.autogenerated === false) {
                // skip writing and return early
                return;
            }
        } catch (err) {
            // If parsing fails, fall back to normal behavior
        }

        shouldWrite = existing !== content;
    }

    if (shouldWrite) {
        fs.writeFileSync(filePath, content);
    }
}
